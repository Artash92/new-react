import React from 'react'

function RuEs5_10() {
  return (
    <div>
 
 <h1>Примеры JavaScript ES5</h1>

 <b>Функция для вычисления степени числа</b>

 <code>

<p>{"function pow(num, exp) { "}</p>

<p>{" var cnt = 0; "}</p>

<p>{"var res = 1; "}</p>

<p>{"while (cnt < exp) { "}</p>

<p>{" res *= num;"}</p>

<p>{" cnt++; "}</p>

<p>{" }"}</p>

<p>{"return res;"}</p>

<p>{"}"}</p>

</code>   

<p><b>pow(num, exp)</b>: Эта функция вычисляет степень числа. Она принимает два параметра, num и exp, и возвращает значение num, возведенное в степень exp. Функция использует цикл while и счетчик, чтобы многократно умножать num на само себя exp раз, пока счетчик не достигнет значения exp.</p>

<b>Функция для вычисления степени числа (альтернативная версия)</b>


<code>

<p>{'function pow2(num1, num2) {'}</p>

<p>{'var num3 = 1;'}</p>

<p>{'for (var i = 1; i <= num2; i++) {'}</p>

<p>{'num3 *= num1;'}</p>

<p>{'}'}</p>

<p>{'return num3;'}</p>

<p>{'}'}</p>

</code>

<p><b>pow2(num1, num2)</b>: Эта функция вычисляет степень числа. Она принимает два параметра, num1 и num2, и возвращает значение num1, возведенное в степень num2. Функция использует цикл for для многократного умножения num1 на само себя num2 раз до завершения цикла.</p>

<b>Функция для проверки, является ли число простым</b>

<code>
  
  <p>{'function isPrime(number) {'}</p> 
  
  <p>{'if (number < 2) {'}</p> 
  
  <p>{'return false;'}</p> 
  
  <p>{'} else if (number == undefined) {'}</p> 
  
  <p>{' return undefined;'}</p> 
  
  <p>{'} else {'}</p> 
  
  <p>{'for (var i = 2; i < number; i++) {'}</p>
  
   <p>{' if (number % i === 0) {'}</p> 
  
   <p>{'return false;'}</p>
  
   <p>{' }'}</p>
  
   <p>{'}'}</p>
  
   <p>{'return true;'}</p>
  
   <p>{'}'}</p>
  
   <p>{'}'}</p>

</code> 

<p><b>isPrime(number)</b>: Эта функция проверяет, является ли число простым. Она принимает параметр number и возвращает true, если число простое, в противном случае она возвращает false. Функция сначала проверяет, меньше ли число 2, в таком случае она сразу же возвращает false. Если число не определено (undefined), она возвращает undefined. В противном случае функция использует цикл for для проверки, делится ли число на любое число между 2 и number (исключая number) без остатка. Если такое число найдено, функция возвращает false. Если такое число не найдено, функция возвращает true.</p>

<h4>Создание пирамиды с помощью звездочек в JavaScript</h4>

<code>
    <p>{"var x = 6; "}</p>
    
    <p>{'var string = "";'}</p>

<p>{"for (var i = 1; i <= x; i++) {"}</p>

<p>{"for (var y = 1; y <= x - i; y++) {"}</p>

<p>{'string += " ";'}</p>

<p>{"}"}</p>

<p>{" for (var k = 0; k < 2 * i - 1; k++) {"}</p>

<p>{' string += "*"; '}</p>

<p>{" }"}</p>

<p>{'string += "\\n";'}</p>

<p>{"}"}</p>

<p>{"console.log(string);"}</p>

</code>

<p>Этот код создает пирамиду с использованием символов звездочки ('*') и пробелов.</p>

<p>Код начинается с определения переменной 'x' со значением 6 и пустой строки 'string'. Затем он использует цикл for для итерации по каждой строке пирамиды, начиная с 1 и до 'x'.</p>

<p>Внутри первого цикла for используется еще один цикл for для добавления пробелов перед звездочками. Он добавляет (x-i) количество пробелов перед каждой строкой звездочек.</p>

<p>Затем используется второй цикл for для добавления звездочек в строку. Количество звездочек, добавленных в каждой строке, задается формулой 2*i-1, где 'i' - текущий номер строки.</p>   

<p>Наконец, к каждой строке добавляется символ перевода строки, и готовая строка выводится в консоль с помощью метода console.log().</p>

<b>Создание узора пирамиды со звездами и цифрами</b>

<code>

<p>{'var lineCount = 5;'}</p>
    
<p>{"var symb = '*';"}</p>

<p>{"var result = ''; "}</p>

<p>{'for (var i = 0; i < lineCount; i++){'}</p>

<p>{'for(var j = 0; j < lineCount - i; j++){'}</p>

<p>{"result += '1'; "}</p>

<p>{' }'}</p>

<p>{"result += symb + '\\n;'"}</p>

<p>{" symb += ' *';"}</p>

<p>{"}"}</p>

<p>{"console.log(result)"}</p>

</code>

<p>Данный код создает узор из звездочек и чисел в форме пирамиды. Сначала определяется количество строк для пирамиды и символ, используемый в узоре (в данном случае - '*'). Затем используются вложенные циклы для создания каждой строки пирамиды, начиная с основания и добавляя по одному символу каждый раз, пока не достигнет вершины. Числа в узоре представлены цифрой '1'. Каждая строка пирамиды создается путем добавления соответствующего количества '1', за которыми следует символ и знак переноса строки. Символ, используемый для каждой строки, обновляется с помощью оператора конкатенации строк, добавляя дополнительную звездочку для каждой новой строки. Наконец, полученный узор выводится в консоль с помощью функции 'console.log'.</p>

<h3>JavaScript функции для генерации чисел Фибоначчи</h3>

<b>Пример</b>

<code> 

<p>{"function fibo(num) { "}</p>

<p>{"if (isNaN(+num)) { "}</p>

<p>{"return 'ERROR'; "}</p>

<p>{" } "}</p>

<p>{"var firstN = 0; "}</p>

<p>{" var secondN = 1; "}</p>

<p>{"while (firstN < num) {"}</p>

<p>{" console.log(firstN); "}</p>

<p>{" secondN = firstN + secondN; "}</p>

<p>{"firstN = secondN - firstN; "}</p>

<p>{"}"}</p>

<p>{"}"}</p>

<p>{"fibo(55);"}</p>

</code>

<b>Пример</b>

<code>
      <p>{"function fibonachi(num) {"}</p>

      <p>{"var num1 = 0;"}</p>

      <p>{"var num2 = 1;"}</p>

      <p>{' if (typeof num !== "number") {'}</p>

      <p>{'console.error("write only numbers");'}</p>

      <p>{"} else {"}</p>

      <p>{"for (var i; num1 < num;) {"}</p>

      <p>{" console.log(num1);"}</p>

      <p>{" i = num1 + num2;"}</p>

      <p>{"num1 = num2;"}</p>

      <p>{"num2 = i;"}</p>

      <p>{" }"}</p>

      <p>{" }"}</p>

      <p>{"}"}</p>

      <p>{"fibonachi(100);"}</p>
    
    </code>

    <b>Пример</b>

    <code>
      
      <p>{"function fibonachi(n) {"}</p>

      <p>{' if (typeof n === "number") {'}</p>

      <p>{" var a = 0; "}</p>

      <p>{"var b = 1; "}</p>

      <p>{"var result = 0;"}</p>

      <p>{" for (; a < n;) {"}</p>

      <p>{" console.log(a)"}</p>

      <p>{"result = a + b;"}</p>

      <p>{"  a = b;"}</p>

      <p>{" b = result; "}</p>

      <p>{"}"}</p>

      <p>{" } else {"}</p>

      <p>{'console.error("please write only number")'}</p>

      <p>{"}"}</p>

      <p>{"}"}</p>
    
    </code>

    <p>Это три различных реализации генератора последовательности Фибоначчи на JavaScript.</p>

    <p>Первая реализация (fibo) использует цикл while для генерации чисел Фибоначчи до заданного предела (num) и выводит их на экран с помощью console.log(). Сначала проверяется, является ли входное значение допустимым числом, и если нет, возвращается сообщение об ошибке.</p>

    <p>Вторая реализация (fibonachi) использует цикл for для генерации чисел Фибоначчи до заданного предела (num) и выводит их на экран с помощью console.log(). Сначала проверяется, является ли входное значение допустимым числом, и если нет, выводится сообщение об ошибке в консоль.</p>

    <p>Третья реализация (fibonachi) также использует цикл for для генерации чисел Фибоначчи до заданного предела (n) и выводит их на экран с помощью console.log(). Сначала проверяется, является ли входное значение допустимым числом, и если нет, выводится сообщение об ошибке в консоль. В этой реализации для генерации следующего числа Фибоначчи используются три переменные: a, b и result. Она начинается с a = 0 и b = 1, а на каждой итерации вычисляет сумму a и b, сохраняет результат в переменной result, устанавливает a равным b, а b равным result.</p>

    <h3>Шахматная доска на JavaScript</h3>

    <code>
  <p>{"function chess(rows, symbolOne, symbolTwo, currentRow) {"}</p>

  <p>{"var symbol = ' ';"}</p>

  <p>{'if (typeof rows != "number"'}</p>

  <p>{'|| typeof symbolOne != "string"'}</p>

  <p>{'|| typeof symbolTwo != "string") {'}</p>

  <p>{' console.error("Invalid params");'}</p>

  <p>{"return; "}</p>

  <p>{"}"}</p>

  <p>{"rows = rows || 8;"}</p>

  <p>{' symbolOne = symbolOne || " ⬛";'}</p>
  
  <p>{'symbolTwo = symbolTwo || " ⬜";'}</p>

  <p>{"currentRow = currentRow || 1;"}</p>

  <p>{" if (currentRow > rows) return '';"}</p>

  <p>{" for (var i = 0; i < rows / 2; i++) {"}</p>

  <p>{"symbol += symbolOne + symbolTwo;"}</p>

  <p>{" }"}</p>

  <p>{' symbol += "\\n";'}</p>

  <p>{"symbol += chess(rows, symbolTwo, symbolOne, currentRow + 1);"}</p>

  <p>{" return symbol;"}</p>
  
  <p>{'}'}</p>

  <p>{'console.log(chess(8, "⬛", "⬜"))'}</p>
  
  </code>  

  <p>Этот код определяет рекурсивную функцию "chess", которая принимает четыре параметра: "rows", "symbolOne", "symbolTwo" и "currentRow". Цель функции - создать строковое представление шахматной доски, чередуя два символа, "symbolOne" и "symbolTwo", для каждой клетки на доске.</p>

  <p>Функция сначала проверяет, являются ли входные параметры допустимыми, то есть является ли "rows" числом, а "symbolOne" и "symbolTwo" строками. Если какие-либо параметры недопустимы, функция возвращает сообщение об ошибке и выходит из функции.</p>
    
  <p>Затем устанавливаются значения по умолчанию для "rows", "symbolOne" и "symbolTwo", если они не были предоставлены. Значение по умолчанию для "rows" равно 8, а значение по умолчанию для "symbolOne" и "symbolTwo" - два символа Unicode, представляющих черный и белый квадраты соответственно.</p>

  <p>Затем функция проверяет, достиг ли она конца шахматной доски (то есть, "currentRow" больше "rows"). Если это так, она возвращает пустую строку и выходит из функции.</p> 

  <p>Если конец шахматной доски еще не достигнут, функция создает строку "symbol", добавляя поочередно "symbolOne" и "symbolTwo" "rows / 2" раз (поскольку каждая строка состоит из "rows / 2" пар символов).</p>

  <p>Затем она добавляет символ переноса строки к строке "symbol" и вызывает рекурсивно функцию "chess", меняя местами "symbolOne" и "symbolTwo" и увеличивая "currentRow" на 1.</p>  

  <p>Наконец, функция возвращает строку "symbol", которая содержит всю шахматную доску. Последняя строка кода вызывает функцию "chess" с "rows", установленным на 8, а "symbolOne" и "symbolTwo" установлены на символы Unicode, представляющие черный и белый квадраты соответственно, и выводит полученную шахматную доску в консоль.</p>



    </div>
  )
}

export default RuEs5_10;