import React from 'react'

 function RuEs5_7() {
  return (
    <div>
   
    <h1>Объектно-ориентированное программирование, или ООП</h1>

<p>Объектно-ориентированное программирование, или ООП, является парадигмой программирования, которая акцентирует внимание на объектах, классах и инкапсуляции. В JavaScript ES5 ООП реализуется с помощью конструкторов функций и прототипов.</p>

<p>Конструктор функций - это специальная функция, которая используется для создания и инициализации объектов. Конструкторы функций определяются с помощью ключевого слова function, а их названия обычно начинаются с заглавной буквы, чтобы отличать их от обычных функций. Ключевое слово this используется внутри конструктора функции для ссылки на создаваемый объект. Вот пример:</p>

<p>{'function Person(name, age) {'}</p>

<p>{'this.name = name;'}</p>

<p>{'this.age = age;'}</p>

<p>{'}'}</p>

<p>{'var person1 = new Person("Alice", 25);'}</p>

<p>{'var person2 = new Person("Bob", 30);'}</p>

<p>{'console.log(person1.name); // "Alice"'}</p>

<p>{'console.log(person2.age); // 30'}</p>

<p>В этом примере функция Person используется в качестве конструктора для создания двух объектов Person, person1 и person2. Свойства name и age устанавливаются с помощью ключевого слова this внутри конструктора функции.</p>

<p>В дополнение к конструкторам функций, прототипы используются для реализации наследования и обмена методами и свойствами между объектами. Каждый объект в JavaScript имеет прототип, который является другим объектом, от которого объект наследует. Свойства и методы могут быть добавлены к прототипу объекта с помощью свойства prototype. Вот пример:</p>
   
<p>{'function Person(name, age) {'}</p>

<p>{'this.name = name;'}</p>

<p>{' this.age = age;'}</p>

<p>{'}'}</p>

<p>{'Person.prototype.greet = function() {'}</p>

<p>{'console.log("Hello, my name is" + this.name + "and I am" + this.age + "years old.");'}</p>

<p>{'}'}</p>

<p>{'var person1 = new Person("Alice", 25);'}</p>

<p>{'var person2 = new Person("Bob", 30);'}</p>

<p>{'person1.greet(); // "Hello, my name is Alice and I am 25 years old."'}</p>

<p>{'person2.greet(); // "Hello, my name is Bob and I am 30 years old."'}</p>

<p>
В этом примере метод greet добавляется в прототип Person, используя свойство prototype. Этот метод может быть вызван на любом объекте Person, как это показано в вызовах person1.greet() и person2.greet().  
</p>
   
<p>Еще одним концептом ООП в JavaScript ES5 является инкапсуляция, которая относится к практике скрытия деталей реализации и выставления только необходимых интерфейсов для внешнего мира. Это можно достичь с помощью замыканий, которые позволяют функциям получать доступ к переменным в их внешнем контексте даже после возврата внешней функции. Вот пример:</p>

 
  <code>
    {'function Counter() {\n  var count = 0;\n\n  this.increment = function() {\n    count++;\n    console.log(count);\n  };\n\n  this.decrement = function() {\n    count--;\n    console.log(count);\n  };\n}\n\nvar counter1 = new Counter();\nvar counter2 = new Counter();\n\ncounter1.increment(); // 1\ncounter1.increment(); // 2\ncounter1.decrement(); // 1\n\ncounter2.increment(); // 1 '}
  </code>
   
   
 <p>
 В этом примере конструктор функции Counter создает объекты с методами increment и decrement, которые получают доступ к приватной переменной count, используя замыкания. Это гарантирует, что переменная count скрыта от внешнего мира и может быть доступна только через методы, предоставляемые объектом Counter. 
  </p>  
   
  <b>Объектно-ориентированное программирование (ООП) с примитивными значениями в JavaScript ES5</b>
   
<p>{'function Person(name, age, gender) {'}</p>

<p>{'this.name = name;'}</p>

<p>{' this.age = age;'}</p>

<p>{'this.gender = gender;'}</p>

<p>{' this.printDetails = function() {'}</p>

<p>{'console.log("Name: " + this.name);'}</p>

<p>{'console.log("Age: " + this.age);'}</p>

<p>{'console.log("Gender: " + this.gender);'}</p>

<p>{'}'}</p>

<p>{'}'}</p>

<p>{'var person1 = new Person("John", 25, "male");'}</p>

<p>{'var person2 = new Person("Jane", 30, "female");'}</p>

<p>{'person1.printDetails();'}</p>

<p>{'person2.printDetails();'}</p>

<p>{'var bool = new Boolean(true);'}</p>

<p>{'console.log(bool.valueOf()); // true'}</p>

<p>{'var str = new String("Hello");'}</p>

<p>{'console.log(str.concat(" World")); // "Hello World"'}</p>

<p>{'var num = new Number(10);'}</p>

<p>{'console.log(num.valueOf() + 5); // 15'}</p>

<p>
В этом примере мы определяем функцию-конструктор Person для создания объектов-людей с свойствами name, age и gender. Мы также определяем метод printDetails для объекта Person, чтобы вывести подробности о человеке.  
</p>  

<p>
Затем мы создаем два объекта Person, используя функцию-конструктор, и вызываем метод printDetails для каждого объекта.
</p>

<p>
Затем мы создаем объекты Boolean, String и Number, используя соответствующие функции-конструкторы и демонстрируем некоторые из их методов, такие как valueOf, concat и базовые арифметические операции.  
</p>

<b>В JavaScript ES5 мы можем создавать объекты, используя функции-конструкторы Object и Array. 
  Это форма ООП, называемая созданием объектов на основе конструктора.

</b>

<p>
Чтобы создать объект с помощью функции-конструктора, мы используем ключевое слово new, за которым следует имя функции. Например, чтобы создать объект с использованием функции-конструктора Object, мы можем сделать следующее:

</p>

<p>{'var person = new Object();'}</p>

<p>{'person.name = "John";'}</p>

<p>{'person.age = 30;'}</p>

<p>{'person.job = "Developer";'}</p>

<p>
В приведенном выше примере мы создаем новый объект person, используя функцию-конструктор Object. Затем мы добавляем свойства в этот объект, используя точечную нотацию.  
</p>

<p>
Аналогично, мы можем создать массив, используя функцию-конструктор Array:  
</p>
<p>{'var arr = [];'}</p>
<p>{'arr.push(1);'}</p>
<p>{'arr.push(2);'}</p>
<p>{'arr.push(3);'}</p>
<p>{'console.log(arr); // [1, 2, 3]'}</p>
<p>
В приведенном выше примере мы создаем новый массив arr, используя конструктор Array. Затем мы добавляем элементы в этот массив, используя метод push.  
</p>
<p>
Создание объектов на основе конструкторов полезно, когда нам нужно создать несколько объектов одного типа. Мы можем определить конструктор, который задает начальные значения свойств объекта, а затем создавать новые объекты, используя этот конструктор.  
</p>

<p>
Например, предположим, что мы хотим создать объекты, представляющие автомобили. Мы можем определить конструктор, как показано ниже:  
</p>

<p>{'function Car(make, model, year) {'}</p>

<p>{' this.make = make;'}</p>

<p>{' this.model = model;'}</p>

<p>{' this.year = year;'}</p>

<p>{'}'}</p>

<p>{'var car1 = new Car("Honda", "Civic", 2020);'}</p>

<p>{'var car2 = new Car("Toyota", "Corolla", 2021);'}</p>

<p>
В приведенном выше примере мы определяем конструктор Car, который принимает три параметра (make, model и year) и задает соответствующие свойства объекта с использованием ключевого слова this. Затем мы создаем два объекта автомобиля (car1 и car2), используя этот конструктор.  
</p>

<b>OOP I new RegExp()</b>

<p>{'var str = "Hello, world!";'}</p>

<p>{'var regex = new RegExp(\'\\\\w\', \'g\');'}</p>

<p>{'var matches = str.match(regex);'}</p>

<p>{'console.log(matches); // ["H", "e", "l", "l", "o", "w", "o", "r", "l", "d"]'}</p>

<p>
В приведенном выше примере мы создаем регулярное выражение, которое соответствует любому символу слова (\w), и используем флаг g для выполнения глобального поиска. Затем мы используем метод match(), чтобы найти все совпадения в строке str. Наконец, мы выводим массив совпадений в консоль.
</p>
<p>
Обратите внимание, что мы должны экранировать символ обратной косой черты, когда передаем шаблон регулярного выражения в качестве строки конструктору RegExp. Это связано с тем, что символ обратной косой черты используется для экранирования специальных символов в регулярных выражениях, и мы также должны его экранировать в строке.
</p>
<b>Прототип proto</b>

<p>
Прототипное программирование - это фундаментальная концепция в JavaScript, которая позволяет объектам наследовать свойства и методы от других объектов. Каждый объект в JavaScript имеет прототип, который является другим объектом, от которого он наследует свойства и методы.
</p>

<p>
В ES5 вы можете создать прототип, используя метод Object.create(), который принимает объект в качестве параметра и создает новый объект с прототипом, установленным на этот объект. Затем вы можете добавлять свойства и методы в объект-прототип, которые будут унаследованы всеми объектами, созданными с его прототипом.
</p>

<p>
Вот пример создания прототипа для объекта Person:
</p>

<p>{'var personPrototype = {'}</p>

<p>{'greeting: function() {'}</p>

<p>{'console.log("Привет, меня зовут " + this.name);'}</p>

<p>{'} ,'}</p>

<p>{'farewell: function() {'}</p>

<p>{'console.log("До свидания!");'}</p>

<p>{'}'}</p>

<p>{'};'}</p>

<p>{'var john = Object.create(personPrototype);'}</p>

<p>{'john.name = "John";'}</p>

<p>{'john.greeting(); // выводит: "Привет, меня зовут John"'}</p>

<p>
В этом примере мы сначала определяем объект personPrototype с методом greeting() и методом farewell(). Затем мы создаем новый объект Person - john, вызывая Object.create(personPrototype) и устанавливая его свойство name равным "John". Так как john создан с personPrototype в качестве своего прототипа, он наследует метод greeting() от объекта-прототипа и может вызывать его с помощью john.greeting().
</p>

<b>instanceof</b>

<p>
В JavaScript ES5 instanceof - это оператор, который используется для проверки принадлежности объекта к определенному классу или нет. Он возвращает логическое значение, указывающее, является ли объект экземпляром указанного класса или его подклассов.
</p>

<p>
Синтаксис для instanceof выглядит следующим образом:
</p>

<p>
object instanceof constructor
</p>

<p>
Здесь object - это имя объекта, который нужно проверить, а constructor - это имя конструктора или класса. Оператор instanceof проверяет цепочку прототипов объекта и возвращает true, если объект является экземпляром конструктора или класса, иначе возвращает false.
</p>

<p>
Вот пример:
</p>

<p>{'function Animal(name) {'}</p>

<p>{'this.name = name;'}</p>

<p>{'}'}</p>

<p>{'function Dog(name) {'}</p>

<p>{'Animal.call(this, name);'}</p>

<p>{' }'}</p>

<p>{'Dog.prototype = Object.create(Animal.prototype);'}</p>

<p>{'var myDog = new Dog("Buddy");'}</p>

<p>{'console.log(myDog instanceof Dog);  // true'}</p>

<p>{'console.log(myDog instanceof Animal); // true'}</p>

<p>
В этом примере мы определяем два класса Animal и Dog. Dog наследует от Animal. Мы создаем новый объект Dog и проверяем, является ли он экземпляром как Dog, так и Animal, используя оператор instanceof. Обе проверки возвращают true, потому что myDog является экземпляром обоих классов.  
</p>

<p>
В заключение, instanceof используется для определения того, является ли объект экземпляром определенного класса или его подклассов, путем проверки его цепочки прототипов.  
</p>
    </div>
  )
}



export default RuEs5_7;



