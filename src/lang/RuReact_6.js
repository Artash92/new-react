import React from 'react'

function RuReact_6() {
  return (
    <div>
      <h1>Реакт ссылки (Refs)</h1>

<p>В React, <b>ссылка (ref)</b> - это способ доступа к базовому узлу DOM или экземпляру компонента React отображаемого элемента. Вы можете использовать ссылки, чтобы получить доступ к определенным свойствам или методам компонента, или изменить его поведение.</p>

<p>Вот пример того, как создать ссылку в React:</p>

<code>
     <p>{" import React, { useRef } from 'react'; "}</p>

     <p>{'function TextInput() {'}</p>

     <p>{'const inputRef = useRef(null);'}</p> 

     <p>{'const handleClick = () => {'}</p>

     <p>{'inputRef.current.focus(); '}</p>

     <p>{' };'}</p>

     <p>{'return ('}</p>

     <p>{'<div>'}</p>

     <p>{' <input type="text" ref={inputRef} />'}</p>

     <p>{'<button onClick={handleClick}>Focus Input</button>'}</p>

     <p>{'</div>'}</p>

     <p>{' );'}</p>

     <p>{'}'}</p>
    
  </code>

  <p>В React <b>ref</b> - это способ получения доступа к базовому узлу DOM или экземпляру компонента React отрендеренного элемента. Вы можете использовать refs, чтобы получить доступ к определенным свойствам или методам компонента или изменить его поведение.</p>
  
  <p>Вот пример того, как создать ref в React:</p>
  
  <p>В этом примере мы создаем <b>ref</b> с помощью хука <b>useRef</b>. Затем мы передаем <b>ref</b> элементу <b>input</b> с помощью свойства <b>ref</b>.</p>
  
  <p>Мы также создаем функцию <b>handleClick</b>, которая использует свойство <b>current</b> у <b>ref</b>, чтобы вызвать метод <b>focus</b> на элементе <b>input</b>. Это позволяет установить фокус на вводе, когда пользователь нажимает кнопку "Focus Input".</p>
  
  <p>В целом, использование <b>ref</b> может быть мощным инструментом для доступа и управления компонентами в React. Однако важно использовать их с осторожностью и избегать чрезмерной зависимости от императивного кода, так как это может усложнить понимание и поддержку кода.</p>
  
  <b>Event Emitter</b>

<p>Event Emitter - это шаблон проектирования, который позволяет объектам в программе взаимодействовать друг с другом, запуская и обрабатывая события. Простыми словами, Event Emitter - это механизм для передачи и получения сообщений в программе.</p>

<p>В JavaScript класс EventEmitter является встроенным модулем, который обеспечивает способ реализации этого шаблона. Вот пример того, как использовать EventEmitter в Node.js:</p>

<code>

  <p>{"const EventEmitter = require('events');"}</p>

  <p>{"class MyEmitter extends EventEmitter {}"}</p>

  <p>{"const myEmitter = new MyEmitter();"}</p>

  <p>{"myEmitter.on('event', (arg) => {"}</p>

  <p>{"console.log('Event triggered with argument:', arg);"}</p>

  <p>{"});"}</p>

  <p>{"myEmitter.emit('event', 'Hello, world!');"}</p>

</code>

<p>В этом примере мы создаем пользовательский класс <b>MyEmitter</b>, который расширяет класс <b>EventEmitter</b>. Затем мы создаем экземпляр этого класса и определяем слушатель для события <b>event</b>, используя метод <b>on</b>. Наконец, мы генерируем событие <b>event</b> и передаем строковый аргумент, который вызывает слушатель и записывает аргумент в консоль.</p>

<p>В целом использование эмиттера событий может быть полезным способом реализации шаблона издатель-подписчик в вашем коде, где различные части вашей программы могут общаться друг с другом, не будучи тесно связанными друг с другом. Однако важно использовать этот шаблон с умом и не полагаться слишком сильно на события, так как это может сделать ваш код более сложным для понимания и отладки.</p>

<p><b>В React</b> вы можете использовать шаблон эмиттера событий для связи между различными компонентами в вашем приложении. Это может быть полезно для передачи данных или запуска действий между компонентами, которые не связаны напрямую друг с другом.</p>

<p>Один из способов реализации шаблона эмиттера событий в React - использовать стороннюю библиотеку, такую как <b>eventemitter3 или mitt</b>. Эти библиотеки предоставляют простой API для создания и подписки на события, и могут использоваться как с классовыми, так и с функциональными компонентами с хуками.</p>

<p>Вот пример того, как использовать <b>eventemitter3</b> в компоненте React:</p>

<code>

<p>{"import React, { useEffect } from 'react'; "}</p>

<p>{"import EventEmitter from 'eventemitter3'; "}</p>

<p>{" const emitter = new EventEmitter(); "}</p>

<p>{"function ComponentA() {"}</p>

<p>{" useEffect(() => { "}</p>

<p>{"emitter.emit('eventA', { data: 'Hello from ComponentA' });"}</p>

<p>{"}, []);"}</p>

<p>{"return <div>ComponentA</div>; "}</p>

<p>{"} "}</p>

<p>{"function ComponentB() {"}</p>

<p>{"useEffect(() => {"}</p>

<p>{"emitter.on('eventA', handleEventA);  "}</p>

<p>{"return () => emitter.off('eventA', handleEventA);"}</p>

<p>{" }, []);"}</p>

<p>{"const handleEventA = (payload) => {"}</p>

<p>{"console.log('Received eventA:', payload.data); "}</p>

<p>{" }; "}</p>

<p>{"return <div>ComponentB</div>; "}</p>

<p>{"}"}</p>

</code>

<p>В этом примере мы создаем экземпляр <b>EventEmitter, называемый emitter</b>. В <b>ComponentA</b> мы используем хук <b>useEffect</b>, чтобы вызвать событие <b>eventA</b> с некоторыми данными. В <b>ComponentB</b> мы используем хук <b>useEffect</b>, чтобы подписаться на событие <b>eventA</b> и определяем функцию обратного вызова <b>handleEventA</b>, которая записывает данные в консоль.</p>

<p>Когда монтируется ComponentA, оно вызывает событие eventA с некоторыми данными. Когда монтируется ComponentB, он подписывается на событие eventA и начинает прослушивать любые события с этим именем. Когда происходит событие eventA, вызывается handleEventA с данными, и она записывает сообщение в консоль.</p>

<p>В целом, использование шаблона эмиттера событий в React может быть полезным способом реализации коммуникации между компонентами, которые не прямо связаны между собой. Однако важно использовать этот шаблон с умом и не полагаться на него слишком сильно, так как это может сделать ваш код более сложным для понимания и отладки.</p>

<h4>Анимация в React</h4>

<p>В React вы можете добавлять анимации в ваши компоненты, используя различные техники. Анимации могут сделать ваш пользовательский интерфейс более увлекательным и обеспечить визуальную обратную связь пользователю, когда что-то меняется.</p>

<p>Один из популярных способов реализации анимаций в React - это использование CSS-переходов или анимаций. Вы можете добавлять CSS-классы к вашим компонентам, чтобы запускать эти анимации, и использовать проп <b>className</b> в React, чтобы переключать классы на основе состояния компонента.</p>

<p>Вот пример того, как использовать CSS-переходы для анимации кнопки при щелчке:</p>

<code>
<p>{"import React, { useState } from 'react';"}</p> 

<p>{" import './Button.css'; "}</p>

<p>{"function Button() {"}</p>

<p>{" const [isClicked, setIsClicked] = useState(false); "}</p>

<p>{"const handleClick = () => { "}</p>

<p>{" setIsClicked(true); "}</p>

<p>{" setTimeout(() => setIsClicked(false), 1000); "}</p>

<p>{" }; "}</p>

<p>{"return (  "}</p>

<p>{" <button className={`button ${isClicked ? 'clicked' : ''}`} onClick={handleClick}> "}</p>

<p>{"Click me!  "}</p>

<p>{"</button>  "}</p>

<p>{"); "}</p>

<p>{" }"}</p>

</code>

<p>В этом примере мы определяем компонент с названием <b>Button</b>, который использует хук <b>useState</b>, чтобы отслеживать, была ли нажата кнопка или нет. Когда кнопка нажимается, мы устанавливаем состояние <b>isClicked</b> в значение <b>true</b>, что добавляет класс <b>clicked</b> к кнопке. Затем мы используем <b>setTimeout</b>, чтобы через 1 секунду удалить класс <b>clicked</b>, что запускает переход обратно в исходное состояние.</p>

<p>Мы также определяем файл CSS с названием <b>Button.css</b>, который определяет стили для кнопки и класса <b>clicked</b>:</p>

<code>
  <p>{'.button {'}</p>

  <p>{'background-color: blue;'}</p>

  <p>{'color: white;'}</p>

  <p>{'padding: 10px 20px;'}</p>

  <p>{'border: none;'}</p>

  <p>{'border-radius: 5px;'}</p>

  <p>{'transition: background-color 0.5s;'}</p>

  <p>{'}'}</p>

  <p>{'.clicked {'}</p>

  <p>{'background-color: red;'}</p>

  <p>{'}'}</p>

</code>

<p>В этом CSS-файле мы определяем стили для кнопки и указываем свойство <b>transition</b> на классе <b>button</b> для анимации изменений свойства <b>background-color</b>. Мы также определяем класс <b>clicked</b>, который изменяет цвет фона на красный, когда он применяется.</p>

<p>Еще один способ реализации анимаций в React - использовать стороннюю библиотеку, такую ​​как <b>react-spring или framer-motion</b>. Эти библиотеки обеспечивают более гибкий API для создания сложных анимаций и могут быть полезны для более продвинутых случаев использования.</p>

<p><b>react-transition-group</b> - это сторонняя библиотека для React, которая предоставляет способ легко добавлять CSS-переходы и анимации к вашим компонентам. Он предоставляет набор компонентов и API для управления жизненным циклом переходов, включая монтирование и демонтаж элементов, добавление и удаление классов и задержку анимаций.</p>

<b>{'npm install react-transition-group'}</b>

<p>Основные компоненты в <b>react-transition-group</b> - это Transition, CSSTransition и TransitionGroup. Вот краткий обзор каждого компонента:</p>

<p>• <b>Transition</b>: Этот компонент определяет основной жизненный цикл перехода, включая состояния входа, введенного, выхода и выведенного. Вы можете использовать этот компонент, чтобы запускать </p>

<p>• <b>CSSTransition</b>: Этот компонент расширяет компонент <b>Transition</b> и добавляет поддержку CSS-переходов и анимаций. Вы можете указать CSS-классы, которые применяются к вашему компоненту в различных стадиях перехода, таких как <b>enter, enter-active, exit и exit-active</b>.</p>

<p>• <b>TransitionGroup</b>: Этот компонент используется для управления набором компонентов <b>Transition or CSSTransition</b>. Он отслеживает монтирование и демонтаж компонентов и может применять различные эффекты перехода к каждому компоненту. </p>

<p>Вот пример использования <b>react-transition-group</b> для добавления анимации появления при монтировании компонента:</p>

<code>
  <p>{"import React, { useState } from 'react'; "}</p>

  <p>{"import { CSSTransition } from 'react-transition-group'; "}</p>

  <p>{"import './FadeIn.css'; "}</p>

  <p>{"function FadeIn() { "}</p>

  <p>{"const [isMounted, setIsMounted] = useState(false); "}</p>

  <p>{"const handleMount = () => setIsMounted(true); "}</p>

  <p>{"return ( "}</p>

  <p>{"<> "}</p>

  <p>{" <button onClick={handleMount}>Mount component</button> "}</p>

  <p>{'<CSSTransition in={isMounted} timeout={300} classNames="fade"> '}</p>

  <p>{' <div className="content">Hello, world!</div> '}</p>

  <p>{"</CSSTransition> "}</p>

  <p>{" </> "}</p>

  <p>{"); "}</p>

  <p>{"} "}</p>

</code>

<p>В этом примере мы определяем компонент с именем <b>FadeIn</b>, который использует хук <b>useState</b> для отслеживания того, был ли компонент смонтирован или нет. Когда кнопка нажимается, мы устанавливаем состояние <b>isMounted</b> в <b>true</b>, что запускает компонент <b>CSSTransition</b> для рендеринга элемента <b>content</b> с эффектом появления. Мы также определяем файл CSS с именем <b>FadeIn.css</b>, который определяет стили и анимацию для эффекта появления:</p>

<code>
  <p>{" .fade-enter { "}</p>

  <p>{"opacity: 0; "}</p>

  <p>{"} "}</p>

  <p>{".fade-enter-active { "}</p>

  <p>{" opacity: 1; "}</p>

  <p>{" transition: opacity 300ms ease-in; "}</p>

  <p>{"} "}</p>

  <p>{".fade-exit { "}</p>

  <p>{"opacity: 1; "}</p>

  <p>{"} "}</p>

  <p>{".fade-exit-active { "}</p>

  <p>{"opacity: 0; "}</p>
  
  <p>{"transition: opacity 300ms ease-out; "}</p>

  <p>{"}"}</p>

</code>

<p>В этом файле CSS мы определяем классы для разных стадий перехода. Когда компонент входит, у него непрозрачность равна 0 (<b>fade-enter</b>), и он переходит к непрозрачности 1 за 300 мс (<b>fade-enter-active</b>). Когда компонент выходит, у него непрозрачность равна 1 (<b>fade-exit</b>), и он переходит к непрозрачности 0 за 300 мс (<b>fade-exit-active</b>).</p>

<p>В целом, добавление анимаций к вашим компонентам React может сделать ваш интерфейс более привлекательным и обеспечить визуальную обратную связь пользователю. Используя CSS-переходы или анимации, или стороннюю библиотеку, вы можете легко добавлять анимации к своим компонентам и делать их более динамичными.</p>

    </div>
  )
}

export default RuReact_6;